package mps

// THIS FILE WAS GENERATED BY "kernels/kernels_gen.go" AND CREATED THROUGH
// THE "go generate" COMMAND. DO NOT EDIT.

var (
	pyKernel = []byte("import json\nimport os.path\nimport pandas as pd\nimport pickle\nimport StringIO\nimport subprocess\nimport os\nimport sys\nimport terragon\nimport time\nimport traceback\n\n\"\"\"\nSorry for the weird variable names throughout this script. Because the user's\ncode is loaded and executed within the same variable space as this code, I've\nprefixed all variable names with two underscores to prevent name clashes.\n\"\"\"\n\ndef mkdir_p(p):\n    if os.path.isdir(p):\n        return\n    dir = os.path.dirname(p)\n    if dir:\n        mkdir_p(dir)\n    os.mkdir(p)\n\n# redirect all stdout to stderr\n__stdout = sys.stdout\nsys.stdout = sys.stderr\n\n__model_name = os.environ[\"MODELNAME\"]\n\nprint \"Evaluating user model code\",\n\n# This git command will show the contents of the bundle at a certain commit\n# command: git show COMMIT_SHA:bundle.json\nwith open(sys.argv[1], 'r') as f:\n    __bundle = json.load(f)\n\n__currdir = os.path.dirname(os.path.realpath(__file__))\n\nprint \"Creating user modules\"\n\nif \"modules\" in __bundle:\n    for __module in __bundle[\"modules\"]:\n        time.sleep(.1)\n        __n = __module[\"name\"]\n        __p = os.path.join(__currdir, __module[\"parent_dir\"])\n        print \"creating module %s in dir %s\" % (__n, __p)\n        if __module[\"parent_dir\"]:\n            print \"package dir detected running mkdir -p %s\" % __p\n            mkdir_p(__p)\n        with open(os.path.join(__p, __n), 'wb+') as __f:\n            __f.write(__module[\"source\"])\n\nprint \"Checking for pip requirements\"\n\n# Rather than creating another file, I just load the code using `exec()`\nif \"future\" in __bundle:\n    print \"Future imports detected:\\n%s\" % __bundle['future'],\n    exec(__bundle[\"future\"] + \"\\n\" + __bundle[\"code\"])\nelse:\n    exec(__bundle['code'])\n\nprint \"Loading user objects:\",\ntime.sleep(.01)\n\n# Load each object into the `__tmp` variable then reassign it\nfor __name,__pk in __bundle['objects'].iteritems():\n    print \"Loading object [%s]\" % __name,\n    __tmp = None\n    try:\n\t__tmp = pickle.loads(__pk)\n    except:\n\t__tmp = terragon.loads_from_base64(__pk)\n    if __tmp is None:\n\tprint \"Could not load object %s\" % __name,\n\tsys.exit(2)\n    exec('%s = __tmp' % (__name,))\n\n# Create an instance of the user's model as `__YhatModel`\n__model_class = __bundle[\"className\"]\nexec(\"__YhatModel = %s()\" % (__model_class,))\n\n# These things can be big. Important to delete the bundle\ndel __bundle\n\n# the kernel communicates with the parent app through stdout. this function\n# open's that channel, send a message, then closes it again\ndef __yhat_return(__msg):\n    __stdout.write(__msg)\n    __stdout.flush()\n\n__yhat_return(json.dumps({\"status\":\"UP\"}))\n\nwhile True:\n    __line = sys.stdin.readline()\n    __yhat_id = None\n    # Attempt to convert the incoming JSON to a python data structure\n    try:\n\t__data = json.loads(__line)\n\tif \"yhat_id\" in __data:\n\t    __yhat_id = __data.pop(\"yhat_id\")\n\telse:\n\t    print \"Got request with no yhat_id\"\n\t    continue\n\n        if \"heartbeat\" in __data:\n            __yhat_return(json.dumps({\"heartbeat_response\": __data[\"heartbeat\"]}))\n            continue\n\n\tif \"body\" in __data:\n\t    __body = __data.pop(\"body\")\n\telse:\n\t    __body = None\n    except Exception as e:\n\tprint \"JSON parsing error on incoming data\",\n\t__err_msg = {\n\t    \"error\": str(e),\n\t    \"yhat_id\": __yhat_id,\n\t    \"yhat_model\": __model_name\n\t}\n\t__yhat_return(json.dumps(__err_msg))\n\tcontinue\n\n    # Time to make a prediction\n    try:\n\t__result = __YhatModel.execute(__body)\n\tif isinstance(__result, pd.DataFrame):\n\t    # Our \"standard\" method for converting data frames to json\n\t    __colnames = __result.columns\n\t    __result = __result.transpose()\n\t    __result = __result.to_json(orient=\"values\", date_format=\"iso\")\n\t    __result = json.loads(__result)\n\t    __result = dict(zip(__colnames, __result))\n\t__result = {\n\t    \"result\": __result,\n\t    \"yhat_id\": __yhat_id,\n\t    \"yhat_model\": __model_name\n\t}\n\t__yhat_return(json.dumps(__result))\n    except Exception as e:\n\t__err_msg = {\n\t    \"error\": str(e),\n\t    \"yhat_id\": __yhat_id,\n\t    \"yhat_model\": __model_name\n\t}\n\t__yhat_return(json.dumps(__err_msg))\n\tprint \"Error in model code:\",\n\t__stack_trace = StringIO.StringIO()\n\ttraceback.print_exc(file=__stack_trace)\n\tprint __stack_trace.getvalue().strip(),\n")
	rKernel = []byte("#!/usr/bin/env Rscript\n\nsink(stderr())\n\n# Variable naming note: I'm prefixing all variables with 'yhat.' to avoid\n# conflicts with user created variables\n\nyhat.model.name <- Sys.getenv(\"MODELNAME\", \"yhatmodel\")\n\nyhat.show <- sprintf(\"cat %s\", commandArgs(trailingOnly = TRUE)[1])\n\n# Convert the bundle into an Rdata file and load it into memory\nsystem(paste(yhat.show,\n\t     \" | jq .image --raw-output | base64 --decode > model.Rdata\"))\n\nload(\"model.Rdata\")\n\nsuppressWarnings(suppressMessages(library(\"jsonlite\")))\nsuppressWarnings(suppressMessages(library(\"rjson\")))\n\nif (\"model.require\" %in% ls()){\n    model.require()\n}\n\n# if we don't have a model.transform function, we're just going\n# to set it to the Identity function\nif (! \"model.transform\" %in% ls()) {\n    cat(\"model.transform function not found. function will not be executed.\\n\")\n    model.transform <- I\n}\n\n# Open the channel to the parent process by turning off sink, send some JSON\n# then reactivate sink\nyhat.return <- function(msg){\n    sink()\n    cat(msg)\n    sink(stderr())\n}\n\n# Something bad has happend. We'd better tell the user.\nyhat.return.error <- function(msg, yhat.id) {\n   yhat.errmsg <- data.frame(error=msg, yhat_id=yhat.id)\n   yhat.errmsg <- rjson::toJSON(yhat.errmsg)\n   yhat.return(yhat.errmsg)\n}\n\n# Let the parent server know that we're ready to make predictions\nyhat.msg <- '{\"status\": \"UP\"}'\nyhat.return(yhat.msg)\n\nyhat.f <- file(\"stdin\")\nopen(yhat.f)\n# returns string w/o leading or trailing whitespace\ntrim <- function (x) gsub(\"^\\\\s+|\\\\s+$\", \"\", x)\nwhile(length(yhat.line <- trim(readLines(yhat.f,n=1))) > 0) {\n    # You can't use `next` from inside an error function so we'll maintain\n    # a flag to enable sequential try/catch statements\n    yhat.model.error <- FALSE\n    is.multiargs <- FALSE\n\n    #####################################################\n    ## Attempt to convert incoming JSON to an R object ##\n    #####################################################\n    tryCatch({\n\tyhat.data <- jsonlite::fromJSON(yhat.line)\n\tif(\"yhat_id\" %in% names(yhat.data)) {\n\n        if(\"heartbeat\" %in% names(yhat.data)) {\n\t        yhat.msg <- rjson::toJSON(data.frame(heartbeat_response=yhat.data$heartbeat))\n\t        yhat.return(yhat.msg)\n            next\n        }\n\n\t    yhat.id <- yhat.data$yhat_id\n\t    # this is how you delete an element in a list\n\t    yhat.data$yhat_id <- NULL\n\t    if(\"args\" %in% names(yhat.data)) {\n\t      yhat.data.input <- yhat.data$args\n\t      is.multiargs <- TRUE\n\t    } else {\n\t      # use rjson instead of jsonlite for \"raw data\"\n\t      yhat.data <- rjson::fromJSON(yhat.line)\n\t      yhat.data.input <- yhat.data$body\n\t    }\n\t} else {\n\t    cat(\"Got request with no yhat_id\\n\")\n\t    yhat.model.error <- TRUE\n\t}\n    },\n    error=function(cond) {\n\tprint(cond)\n\tyhat.return.error(\"Could not parse incoming JSON\", \"UNKNOWNID\")\n\tyhat.model.error <<- TRUE\n    })\n    if (yhat.model.error) { next }\n\n    ############################\n    ## Execute model.tranform ##\n    ############################\n    tryCatch({\n\t# TODO: add in `execute`\n\t# if it's a list, then we'll assume that we're handling multiple args\n\tif (is.multiargs==TRUE) {\n\t  yhat.transform.result <- do.call(model.transform, yhat.data.input)\n\t} else {\n\t  yhat.transform.result <- model.transform(yhat.data.input)\n\t}\n    },\n    error=function(cond){\n\t# grab the source code of `model.transform` and error msg\n\tyhat.errmsg <- paste(c(\"Error in model.transform function\\n\",\n\t\t\t\tas.character(cond),\n\t\t\t\t\"model.transform <- \",\n\t\t\t\tpaste(deparse(model.transform),collapse=\"\\n\")),\n\t\t\t     collapse=\"\")\n\tcat(yhat.errmsg)\n\tyhat.return.error(yhat.errmsg)\n\tyhat.model.error <<- TRUE\n    })\n    if (yhat.model.error) { next }\n\n    ###########################\n    ## Execute model.predict ##\n    ###########################\n    tryCatch({\n\tyhat.model.result <- model.predict(yhat.transform.result)\n    },\n    error=function(cond){\n\t# grab the source code of `model.predict` and error msg\n\tyhat.errmsg <- paste(c(\"Error in model.predict function\\n\",\n\t\t\t\tas.character(cond),\n\t\t\t\t\"model.predict <- \",\n\t\t\t\tpaste(deparse(model.predict),collapse=\"\\n\")),\n\t\t\t     collapse=\"\")\n\tcat(yhat.errmsg)\n\tyhat.return.error(yhat.errmsg, yhat.id)\n\tyhat.model.error <<- TRUE\n    })\n\n    if (yhat.model.error) {\n      next\n    }\n\n    ################################################################\n    ## convert result of model.predict to JSON and return to user ##\n    ################################################################\n    tryCatch({\n\tyhat.one.row.df <- FALSE\n\tif (is.data.frame(yhat.model.result)) {\n\t  if (nrow(yhat.model.result) == 1) {\n\t    yhat.one.row.df <- TRUE\n\t  }\n\t}\n\tyhat.df.json <- list(\n\t  result=yhat.model.result,\n\t  yhat_id=yhat.id,\n\t  yhat_model=yhat.model.name\n\t)\n\tif (yhat.one.row.df) {\n\t  if (is.null(yhat.data$non_vectorized)) {\n\t    yhat.df.json[[\"one_row_dataframe\"]] = TRUE\n\t  }\n\t}\n\tyhat.msg <- rjson::toJSON(yhat.df.json)\n\tyhat.return(yhat.msg)\n    },\n    error=function(cond){\n\tyhat.errmsg <- paste(c(\"Error converting model result to JSON\\n\",\n\t\t\t       as.character(cond)),\n\t\t\t     collapse=\"\")\n\tcat(yhat.errmsg)\n\tyhat.return.error(yhat.errmsg, yhat.id)\n\tyhat.model.error <<- TRUE\n    })\n    if (yhat.model.error) {\n      next\n    }\n}\n")
)
